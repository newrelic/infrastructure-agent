// Copyright 2020 New Relic Corporation. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
package protocol

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/newrelic/infrastructure-agent/pkg/entity"
)

type MetricType string

// Metric type values
const (
	MetricTypeCount   MetricType = "count"
	MetricTypeSummary MetricType = "summary"
	MetricTypeGauge   MetricType = "gauge"
	MetricTypeRate    MetricType = "rate"
)

const millisSinceJanuaryFirst1978 = 252489600000

type DataV4 struct {
	PluginProtocolVersion
	Integration IntegrationMetadata `json:"integration"`
	DataSets    []Dataset           `json:"data"`
}

type IntegrationMetadata struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

type Dataset struct {
	Common    Common                   `json:"common"`
	Metrics   []Metric                 `json:"metrics"`
	Entity    Entity                   `json:"entity"`
	Inventory map[string]InventoryData `json:"inventory"`
	Events    []EventData              `json:"events"`
}

type Common struct {
	Timestamp  *int64                 `json:"timestamp"`
	Interval   *int64                 `json:"interval.ms"`
	Attributes map[string]interface{} `json:"attributes"`
}

type Metric struct {
	Name       string                 `json:"name"`
	Type       MetricType             `json:"type"`
	Timestamp  *int64                 `json:"timestamp"`
	Interval   *int64                 `json:"interval.ms"`
	Attributes map[string]interface{} `json:"attributes"`
	Value      json.RawMessage        `json:"value"`
}

type Entity struct {
	Name        string                 `json:"name"`
	Type        string                 `json:"type"`
	DisplayName string                 `json:"displayName"`
	Metadata    map[string]interface{} `json:"metadata"`
}

type SummaryValue struct {
	Count float64 `json:"count"`
	Min   float64 `json:"min"`
	Max   float64 `json:"max"`
	Sum   float64 `json:"sum"`
}

// PluginDataV1 supports a single data set for a single entity
type PluginDataV1 struct {
	PluginOutputIdentifier
	PluginDataSet
}

// convertToV3 converts the data structure of an external plugin v1 to the
// structure of a plugin v3. The only difference between v1 and v3 is that v3
// consists of an array of data sets & it has cluster and service fields.
func (pv1 *PluginDataV1) convertToV3(dest *PluginDataV3) {
	dest.PluginOutputIdentifier = pv1.PluginOutputIdentifier
	dest.DataSets = []PluginDataSetV3{
		{
			PluginDataSet: pv1.PluginDataSet,
		},
	}
}

// PluginDataV3 supports an array of data sets, each for a different entity.
// It's also valid for protocol V2, protocol v3 only adds service & cluster
type PluginDataV3 struct {
	PluginOutputIdentifier
	DataSets []PluginDataSetV3 `json:"data"`
}

type PluginDataSetV3 struct {
	PluginDataSet
	Cluster string `json:"cluster"`
	Service string `json:"service"`
}

// A collection of data generated by a plugin for a single entity.
// V2 plugins can produce multiple of these, where V1 produces one per execution.
type PluginDataSet struct {
	Entity    entity.Fields            `json:"entity"`
	Metrics   []MetricData             `json:"metrics"`
	Inventory map[string]InventoryData `json:"inventory"`
	Events    []EventData              `json:"events"`
	// this is here for backcompat with the SDK, but is ignored
	AddHostname bool `json:"add_hostname"`
}

// Basic fields which identify the plugin and the version of its output
type PluginOutputIdentifier struct {
	Name               string      `json:"name"`
	RawProtocolVersion interface{} `json:"protocol_version"` // Left open-ended for validation purposes
	IntegrationVersion string      `json:"integration_version"`
	Status             string      `json:"integration_status"`
}

// InventoryData is the data type for inventory data produced by a plugin data source and emitted to the agent's inventory data store
type InventoryData map[string]interface{}

// MetricData is the data type for events produced by a plugin data source and emitted to the agent's metrics data store
type MetricData map[string]interface{}

// EventData is the data type for single shot events
type EventData map[string]interface{}

// Minimum information to determine plugin protocol
type PluginProtocolVersion struct {
	RawProtocolVersion interface{} `json:"protocol_version"` // Left open-ended for validation purposes
}

func (i InventoryData) SortKey() string {
	if i, ok := i["id"]; ok {
		return i.(string)
	}
	return ""
}

// HasInterval does metric type support interval.
func (t MetricType) HasInterval() bool {
	return t == MetricTypeCount || t == MetricTypeSummary
}

// Converts timestamp to a Time object, accepting timestamps in both
// seconds and milliseconds.
func (m *Metric) Time() time.Time {
	if m.Timestamp == nil {
		return time.Now()
	}

	metricTimestamp := *m.Timestamp

	// We assume that timestamp is in seconds if it's less than
	// January 1st 1978 in milliseconds.
	// We will assume that timestamp is in seconds otherwise.
	// See: https://github.com/timhudson/date-from-num
	if metricTimestamp < millisSinceJanuaryFirst1978 {
		return time.Unix(int64(metricTimestamp), 0)
	} else {
		return time.Unix(0, metricTimestamp*int64(time.Millisecond))
	}
}

func (m *Metric) IntervalDuration() time.Duration {
	if m.Interval == nil {
		return time.Duration(0)
	}

	return time.Duration(*m.Interval * int64(time.Millisecond))
}

func (m *Metric) NumericValue() (float64, error) {
	if m.Type == "gauge" || m.Type == "count" || m.Type == "rate" || m.Type == "cumulative-rate" || m.Type == "cumulative-count" {
		var value float64
		err := json.Unmarshal(m.Value, &value)

		return value, err
	}

	return 0, fmt.Errorf("metric type %v is not gauge or count", m.Type)
}

func (m *Metric) SummaryValue() (SummaryValue, error) {
	if m.Type == "summary" {
		var value SummaryValue
		err := json.Unmarshal(m.Value, &value)

		return value, err
	}

	return SummaryValue{}, fmt.Errorf("metric type %v is not summary", m.Type)
}
